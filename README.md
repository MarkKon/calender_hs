# Haskell Calendar Abstraction

## Goal

### Abstaction of calendar events

At the backbone of the abstraction stands the `Event` datatype. This works as you would expect from a calendar event as found for example in Gcal etc. The main differences are that repeated events are supposed to work differently (i.e. most importantly, repeated events are not done by having just one event with a repeat tag but instead this is moved to so called "Generators": see later), events not only have a category but can also have multiple tags, 

- Beginning Time: as some sort of DateTime
- End Time: as some sort of DateTime
- Event Name: a string with regex checks
- Event id as a unique identifier
- Event Category (of which several can be defined, but each event is only in one category)
- Tags (of which several can be defined and an event can have multiple tags (or none))
- Notes: at least a string, maybe even some kind of markdown-compatible text
- Attachments (to be implemented later)
- Location: 
  - A first implementation should have here a DU between Home, Work and Other
  - Later implementation should specify the Work and Other types more specifically
- Availability (as upwards compatibility: Am I available to scheduling with other people?) DU between Busy and Available
- Anchorage: 
  - A `Pinned` event is one whose time and duration cannot be changed by automatic generation. Any past event must be pinned.
  - An `Unpinned` event is one that is preallocated by a generator but is not yet fixed there. 

### Generators

Generators are going to be the main system in line to manage automatic event generation. This should abstract: 

- automatically assigning repeated events e.g.
  - birthdays (every year)
  - Weekly cleanup (specify day of the week, duration and when during that day it can be done)
  - Repeated events with a specific date and a frequency e.g. a lecture that happens every Monday at exactly 10:15-11:45
  - Clearly for all of these you also need to give the generator a pattern that consists of the important parts of the calendar that you want all of the events generated by the generator to have: Name, category, tag etc.
- Automatically assigning events to handle (shorter or longer) tasks: the plan is that you give a task with a deadline and an approximate time that you need for the completion and the generator automatically lays out events of a maximum length (i.e. you cannot concetrate more than one hour before needing a break)
  - Clearly this generator needs to be changed during the completion of the tasks: if an event is moved into the pinned state (by the user "doing" that event), then the generator must deduce one hour from the total of time (still) needed for the scheduling of the future events for that task. Further, maybe the initial estimate was wrong and more time needs to be alotted to a specific task, then this should be easily doable as well.

Generation is nontrivial in the sense that there is an a priori expansionally big number of ways that `n` events can be alotted. Maybe it is nice to write a proper optimisation model to be generated by the problem, but this too will increase very strongly if too many different generators are in use (the optimisation would have to go over all generators and future pinned events, formulate an optimisation problem and solve it) every time that anything in either the future pinned events or the generators is changed. 

So maybe there are heuristics that are able to reduce either the size of the problem (i.e. not all generators/events need to be considered at the same time) or how often a full optimisation needs to be called (i.e. only do a short-term optimisation such that short-term tasks are changed while long-term tasks are kept unchanged).

The optimisation should optimise over following targets:

- Some indication on finishing tasks "early": not finishing 1h before deadline but maybe before, finishing tasks with a closer deadline sooner than those with a farther deadline
- Some variance between the tasks: By experience I liked it to vary between different tasks as opposed to doing the same thing throughout a whole day.
- Some variance between difficulties: any task should also have an estimated difficulty measure. The scheduling optimisation should alternate difficulties to switch up tasks with high focus need with those that can be done "on the side" to relax the mind. 
- Prioritise solving harder or longer tasks first as these will probably be the ones whose time estimates are off by the most: time estimates should always be changed the earliest possible (think of the situation where 3 hours before the deadline you realise you need another 4 hours to solve the task)

In any case, the optimisation itself could also just be executed with a high tolerance on the solution: The solution space should be big enough for there not to be much of a problem to find a solution in the first place if there even is any (e.g. just greedily fill the time with the task that has the highest priority does that, so any branch and bound should succeed) and then just find a good one of these solutions without putting too much effort.

Maybe the heuristic even does all the work that is actually needed: By assigning every task a rating (high if the ratio time still needed vs. time to deadline is high, low if the task before has same difficulty or is of same generator etc. ) and then just iterating and always just putting next the event with the hightest rating to however much time is alotted.